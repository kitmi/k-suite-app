"use strict";

require("source-map-support/register");

exports.dependsOn = function (features, app, fromFeature) {
  let hasNotEnabled = _.find(_.castArray(features), feature => !app.enabled(feature));

  if (hasNotEnabled) {
    throw new Error(`"${fromFeature}" feature requires "${hasNotEnabled}" feature to be enabled.`);
  }
};

exports.splitControllerAction = function (actionString) {
  let pos = actionString.lastIndexOf('.');

  if (pos <= 0) {
    throw new Error(`Unrecognized controller.action syntax: ${actionString}.`);
  }

  let controller = actionString.substr(0, pos);
  let action = actionString.substr(pos + 1);
  return {
    controller,
    action
  };
};

exports.tryRequire = function (packageName) {
  function tryRequireBy(packageName, mainModule, throwWhenNotFound) {
    try {
      return mainModule.require(packageName);
    } catch (error) {
      if (error.code === 'MODULE_NOT_FOUND') {
        if (throwWhenNotFound) {
          let pkgPaths = packageName.split('/');
          let npmPkgName = pkgPaths[0];

          if (pkgPaths[0].startsWith('@') && pkgPaths.length > 1) {
            npmPkgName += '/' + pkgPaths[1];
          }

          throw new Error(`Module "${packageName}" not found. Try run "npm install ${npmPkgName}" to install the dependency.`);
        }

        return undefined;
      }

      throw error;
    }
  }

  return tryRequireBy(packageName, module) || tryRequireBy(packageName, require.main, true);
};

exports.withName = Base => class extends Base {
  constructor(...args) {
    super(...args);
    this.name = this.constructor.name;
  }

};

exports.withExtraInfo = Base => class extends Base {
  constructor(...args) {
    super(...args);
    let expectedNumArgs = super.constructor.length;

    if (args.length > expectedNumArgs) {
      let extra = args.slice(expectedNumArgs);
      this.extraInfo = extra.length > 1 ? extra : extra[0];
    }
  }

};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9IZWxwZXJzLmpzIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJkZXBlbmRzT24iLCJmZWF0dXJlcyIsImFwcCIsImZyb21GZWF0dXJlIiwiaGFzTm90RW5hYmxlZCIsIl8iLCJmaW5kIiwiY2FzdEFycmF5IiwiZmVhdHVyZSIsImVuYWJsZWQiLCJFcnJvciIsInNwbGl0Q29udHJvbGxlckFjdGlvbiIsImFjdGlvblN0cmluZyIsInBvcyIsImxhc3RJbmRleE9mIiwiY29udHJvbGxlciIsInN1YnN0ciIsImFjdGlvbiIsInRyeVJlcXVpcmUiLCJwYWNrYWdlTmFtZSIsInRyeVJlcXVpcmVCeSIsIm1haW5Nb2R1bGUiLCJ0aHJvd1doZW5Ob3RGb3VuZCIsInJlcXVpcmUiLCJlcnJvciIsImNvZGUiLCJwa2dQYXRocyIsInNwbGl0IiwibnBtUGtnTmFtZSIsInN0YXJ0c1dpdGgiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJtb2R1bGUiLCJtYWluIiwid2l0aE5hbWUiLCJCYXNlIiwiY29uc3RydWN0b3IiLCJhcmdzIiwibmFtZSIsIndpdGhFeHRyYUluZm8iLCJleHBlY3RlZE51bUFyZ3MiLCJleHRyYSIsInNsaWNlIiwiZXh0cmFJbmZvIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQVlBQSxPQUFPLENBQUNDLFNBQVIsR0FBb0IsVUFBVUMsUUFBVixFQUFvQkMsR0FBcEIsRUFBeUJDLFdBQXpCLEVBQXNDO0FBQ3RELE1BQUlDLGFBQWEsR0FBR0MsQ0FBQyxDQUFDQyxJQUFGLENBQU9ELENBQUMsQ0FBQ0UsU0FBRixDQUFZTixRQUFaLENBQVAsRUFBOEJPLE9BQU8sSUFBSSxDQUFDTixHQUFHLENBQUNPLE9BQUosQ0FBWUQsT0FBWixDQUExQyxDQUFwQjs7QUFFQSxNQUFJSixhQUFKLEVBQW1CO0FBQ2YsVUFBTSxJQUFJTSxLQUFKLENBQVcsSUFBR1AsV0FBWSx1QkFBc0JDLGFBQWMsMEJBQTlELENBQU47QUFDSDtBQUNKLENBTkQ7O0FBUUFMLE9BQU8sQ0FBQ1kscUJBQVIsR0FBZ0MsVUFBVUMsWUFBVixFQUF3QjtBQUNwRCxNQUFJQyxHQUFHLEdBQUdELFlBQVksQ0FBQ0UsV0FBYixDQUF5QixHQUF6QixDQUFWOztBQUNBLE1BQUlELEdBQUcsSUFBSSxDQUFYLEVBQWM7QUFDVixVQUFNLElBQUlILEtBQUosQ0FBVywwQ0FBeUNFLFlBQWEsR0FBakUsQ0FBTjtBQUNIOztBQUVELE1BQUlHLFVBQVUsR0FBR0gsWUFBWSxDQUFDSSxNQUFiLENBQW9CLENBQXBCLEVBQXVCSCxHQUF2QixDQUFqQjtBQUNBLE1BQUlJLE1BQU0sR0FBR0wsWUFBWSxDQUFDSSxNQUFiLENBQW9CSCxHQUFHLEdBQUcsQ0FBMUIsQ0FBYjtBQUVBLFNBQU87QUFBRUUsSUFBQUEsVUFBRjtBQUFjRSxJQUFBQTtBQUFkLEdBQVA7QUFDSCxDQVZEOztBQWdCQWxCLE9BQU8sQ0FBQ21CLFVBQVIsR0FBcUIsVUFBVUMsV0FBVixFQUF1QjtBQUV4QyxXQUFTQyxZQUFULENBQXNCRCxXQUF0QixFQUFtQ0UsVUFBbkMsRUFBK0NDLGlCQUEvQyxFQUFrRTtBQUM5RCxRQUFJO0FBQ0EsYUFBT0QsVUFBVSxDQUFDRSxPQUFYLENBQW1CSixXQUFuQixDQUFQO0FBQ0gsS0FGRCxDQUVFLE9BQU9LLEtBQVAsRUFBYztBQUNaLFVBQUlBLEtBQUssQ0FBQ0MsSUFBTixLQUFlLGtCQUFuQixFQUF1QztBQUNuQyxZQUFJSCxpQkFBSixFQUF1QjtBQUNuQixjQUFJSSxRQUFRLEdBQUdQLFdBQVcsQ0FBQ1EsS0FBWixDQUFrQixHQUFsQixDQUFmO0FBQ0EsY0FBSUMsVUFBVSxHQUFHRixRQUFRLENBQUMsQ0FBRCxDQUF6Qjs7QUFDQSxjQUFJQSxRQUFRLENBQUMsQ0FBRCxDQUFSLENBQVlHLFVBQVosQ0FBdUIsR0FBdkIsS0FBK0JILFFBQVEsQ0FBQ0ksTUFBVCxHQUFrQixDQUFyRCxFQUF3RDtBQUNwREYsWUFBQUEsVUFBVSxJQUFJLE1BQU1GLFFBQVEsQ0FBQyxDQUFELENBQTVCO0FBQ0g7O0FBRUQsZ0JBQU0sSUFBSWhCLEtBQUosQ0FBVyxXQUFVUyxXQUFZLHFDQUFvQ1MsVUFBVyw4QkFBaEYsQ0FBTjtBQUNIOztBQUVELGVBQU9HLFNBQVA7QUFDSDs7QUFFRCxZQUFNUCxLQUFOO0FBQ0g7QUFDSjs7QUFFRCxTQUFPSixZQUFZLENBQUNELFdBQUQsRUFBY2EsTUFBZCxDQUFaLElBQXFDWixZQUFZLENBQUNELFdBQUQsRUFBY0ksT0FBTyxDQUFDVSxJQUF0QixFQUE0QixJQUE1QixDQUF4RDtBQUNILENBekJEOztBQWdDQWxDLE9BQU8sQ0FBQ21DLFFBQVIsR0FBb0JDLElBQUQsSUFBVSxjQUFjQSxJQUFkLENBQW1CO0FBQzVDQyxFQUFBQSxXQUFXLENBQUMsR0FBR0MsSUFBSixFQUFVO0FBQ2pCLFVBQU0sR0FBR0EsSUFBVDtBQU1BLFNBQUtDLElBQUwsR0FBWSxLQUFLRixXQUFMLENBQWlCRSxJQUE3QjtBQUNIOztBQVQyQyxDQUFoRDs7QUFpQkF2QyxPQUFPLENBQUN3QyxhQUFSLEdBQXlCSixJQUFELElBQVUsY0FBY0EsSUFBZCxDQUFtQjtBQUNqREMsRUFBQUEsV0FBVyxDQUFDLEdBQUdDLElBQUosRUFBVTtBQUNqQixVQUFNLEdBQUdBLElBQVQ7QUFFQSxRQUFJRyxlQUFlLEdBQUcsTUFBTUosV0FBTixDQUFrQk4sTUFBeEM7O0FBRUEsUUFBSU8sSUFBSSxDQUFDUCxNQUFMLEdBQWNVLGVBQWxCLEVBQW1DO0FBQy9CLFVBQUlDLEtBQUssR0FBR0osSUFBSSxDQUFDSyxLQUFMLENBQVdGLGVBQVgsQ0FBWjtBQU1BLFdBQUtHLFNBQUwsR0FBaUJGLEtBQUssQ0FBQ1gsTUFBTixHQUFlLENBQWYsR0FBbUJXLEtBQW5CLEdBQTJCQSxLQUFLLENBQUMsQ0FBRCxDQUFqRDtBQUNIO0FBQ0o7O0FBZmdELENBQXJEIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29tbW9uIGhlbHBlcnMgZm9yIHNlcnZpY2UgY29udGFpbmVyLlxuICogQG1vZHVsZSBIZWxwZXJzXG4gKi8gXG5cbiAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheS48c3RyaW5nPn0gZmVhdHVyZXMgLSBEZXBlbmRlbmNpZXMgb2Ygb3RoZXIgZmVhdHVyZXMuXG4gICogQHBhcmFtIHtTZXJ2aWNlQ29udGFpbmVyfSBhcHAgLSBPcmlnaW4gc2VydmljZSBjb250YWluZXIgYXBwLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tRmVhdHVyZSAtIERlcGVuZGVudCBmZWF0dXJlLlxuICAqL1xuZXhwb3J0cy5kZXBlbmRzT24gPSBmdW5jdGlvbiAoZmVhdHVyZXMsIGFwcCwgZnJvbUZlYXR1cmUpIHtcbiAgICBsZXQgaGFzTm90RW5hYmxlZCA9IF8uZmluZChfLmNhc3RBcnJheShmZWF0dXJlcyksIGZlYXR1cmUgPT4gIWFwcC5lbmFibGVkKGZlYXR1cmUpKTtcblxuICAgIGlmIChoYXNOb3RFbmFibGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2Zyb21GZWF0dXJlfVwiIGZlYXR1cmUgcmVxdWlyZXMgXCIke2hhc05vdEVuYWJsZWR9XCIgZmVhdHVyZSB0byBiZSBlbmFibGVkLmApO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuc3BsaXRDb250cm9sbGVyQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvblN0cmluZykge1xuICAgIGxldCBwb3MgPSBhY3Rpb25TdHJpbmcubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAocG9zIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgY29udHJvbGxlci5hY3Rpb24gc3ludGF4OiAke2FjdGlvblN0cmluZ30uYCk7XG4gICAgfVxuXG4gICAgbGV0IGNvbnRyb2xsZXIgPSBhY3Rpb25TdHJpbmcuc3Vic3RyKDAsIHBvcyk7XG4gICAgbGV0IGFjdGlvbiA9IGFjdGlvblN0cmluZy5zdWJzdHIocG9zICsgMSk7XG5cbiAgICByZXR1cm4geyBjb250cm9sbGVyLCBhY3Rpb24gfTtcbn07XG5cbi8qKlxuICogVHJ5IHJlcXVpcmUgYSBwYWNrYWdlIG1vZHVsZSBhbmQgc2hvdyBpbnN0YWxsIHRpcHMgaWYgbm90IGZvdW5kLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhY2thZ2VOYW1lXG4gKi9cbmV4cG9ydHMudHJ5UmVxdWlyZSA9IGZ1bmN0aW9uIChwYWNrYWdlTmFtZSkge1xuXG4gICAgZnVuY3Rpb24gdHJ5UmVxdWlyZUJ5KHBhY2thZ2VOYW1lLCBtYWluTW9kdWxlLCB0aHJvd1doZW5Ob3RGb3VuZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG1haW5Nb2R1bGUucmVxdWlyZShwYWNrYWdlTmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ01PRFVMRV9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRocm93V2hlbk5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwa2dQYXRocyA9IHBhY2thZ2VOYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBucG1Qa2dOYW1lID0gcGtnUGF0aHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwa2dQYXRoc1swXS5zdGFydHNXaXRoKCdAJykgJiYgcGtnUGF0aHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnBtUGtnTmFtZSArPSAnLycgKyBwa2dQYXRoc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTW9kdWxlIFwiJHtwYWNrYWdlTmFtZX1cIiBub3QgZm91bmQuIFRyeSBydW4gXCJucG0gaW5zdGFsbCAke25wbVBrZ05hbWV9XCIgdG8gaW5zdGFsbCB0aGUgZGVwZW5kZW5jeS5gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnlSZXF1aXJlQnkocGFja2FnZU5hbWUsIG1vZHVsZSkgfHwgdHJ5UmVxdWlyZUJ5KHBhY2thZ2VOYW1lLCByZXF1aXJlLm1haW4sIHRydWUpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBuYW1lIHByb3BlcnR5IG9mIHdoaWNoIHRoZSB2YWx1ZSBpcyB0aGUgY2xhc3MgbmFtZS5cbiAqIEBtaXhpblxuICogQHBhcmFtIHsqfSBCYXNlIFxuICovXG5leHBvcnRzLndpdGhOYW1lID0gKEJhc2UpID0+IGNsYXNzIGV4dGVuZHMgQmFzZSB7ICAgIFxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVycm9yIG5hbWUuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB9ICAgIFxufTtcblxuLyoqXG4gKiBBZGQgYW4gZXh0cmFJbmZvIHByb3BlcnR5IGFuZCBwYXNzZWQgaW4gYnkgZXh0cmEgY29uc3RydXRvciBhcmd1bWVudHMuXG4gKiBAbWl4aW5cbiAqIEBwYXJhbSB7Kn0gQmFzZSBcbiAqL1xuZXhwb3J0cy53aXRoRXh0cmFJbmZvID0gKEJhc2UpID0+IGNsYXNzIGV4dGVuZHMgQmFzZSB7ICAgIFxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAgICAgbGV0IGV4cGVjdGVkTnVtQXJncyA9IHN1cGVyLmNvbnN0cnVjdG9yLmxlbmd0aDtcblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiBleHBlY3RlZE51bUFyZ3MpIHtcbiAgICAgICAgICAgIGxldCBleHRyYSA9IGFyZ3Muc2xpY2UoZXhwZWN0ZWROdW1BcmdzKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFeHRyYSBlcnJvciBpbmZvLlxuICAgICAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmV4dHJhSW5mbyA9IGV4dHJhLmxlbmd0aCA+IDEgPyBleHRyYSA6IGV4dHJhWzBdO1xuICAgICAgICB9XG4gICAgfVxufTsiXX0=